from abc import ABC, abstractmethod
from typing import List, Tuple

import numpy as np


class ProblemSolver(ABC):

    @abstractmethod
    def solve(self, distance_matrix: np.ndarray, start_node: int = 1, start_cycle: List[int] = None) -> List[int]:
        """ Creates path for given graph.

        :param distance_matrix: distance_matrix of given graph
        :param start_node: index of path start node
        :param start_cycle: start solution to be modified by algorithm (optional)
        :return: Path generated by given implementation of problem solver
        """
        pass


class SearchProblemSolver(ABC):

    @abstractmethod
    def solve(self, distance_matrix: np.ndarray, start_cycle: List[int] = None) -> List[int]:
        """ Creates path for given graph.

        :param distance_matrix: distance_matrix of given graph
        :param start_cycle: start solution to be modified by algorithm (optional)
        :return: Path generated by given implementation of problem solver
        """
        pass


class IteratedSearchProblemSolver(ABC):

    @abstractmethod
    def solve(self,
              distance_matrix: np.ndarray,
              start_cycle: List[int] = None,
              max_time: float = None) -> Tuple[List[int], int]:
        """ Creates path for given graph.

        :param distance_matrix: distance_matrix of given graph
        :param start_cycle: start solution to be modified by algorithm (optional)
        :param max_time: maximum execution time for given algorithm (optional)
        :return: Path generated by given implementation of problem solver
        """
        pass
